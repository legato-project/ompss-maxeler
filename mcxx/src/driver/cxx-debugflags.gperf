/*--------------------------------------------------------------------
  (C) Copyright 2006-2014 Barcelona Supercomputing Center
                          Centro Nacional de Supercomputacion

  This file is part of Mercurium C/C++ source-to-source compiler.

  See AUTHORS file in the top level directory for information
  regarding developers and contributors.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 3 of the License, or (at your option) any later version.

  Mercurium C/C++ source-to-source compiler is distributed in the hope
  that it will be useful, but WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.  See the GNU Lesser General Public License for more
  details.

  You should have received a copy of the GNU Lesser General Public
  License along with Mercurium C/C++ source-to-source compiler; if
  not, write to the Free Software Foundation, Inc., 675 Mass Ave,
  Cambridge, MA 02139, USA.
--------------------------------------------------------------------*/


%{
#include <stdlib.h>
#include <string.h>
#include "cxx-driver.h"
#include "cxx-utils.h"

#define DEBUG_OPTION_REF(x) (offsetof(struct debug_options_tag, x))
%}

struct debug_flags_list_t;
%%
"abort_on_ice", DEBUG_OPTION_REF(abort_on_ice), "When an error condition is detected, the compiler will raise a SIGABRT signal. This is useful for debugging"
"abort_on_error_message", DEBUG_OPTION_REF(abort_on_error_message), "When an error diagnostic is emitted, the compiler will raise a SIGABRT signal. This is useful for debugging"
"analysis_info", DEBUG_OPTION_REF(analysis_info), "Adds analysis information in text format in the source code"
"analysis_perf", DEBUG_OPTION_REF(analysis_perf), "Prints the performance information of the static analysis"
"analysis_verbose", DEBUG_OPTION_REF(analysis_verbose), "Prints the results of the static analysis"
"backtrace_on_ice", DEBUG_OPTION_REF(backtrace_on_ice), "When an error condition is detected, compiler will print a backtrace to the stderr"
"binary_check", DEBUG_OPTION_REF(binary_check), "Performs a binary check between the binary output"
"debug_lexer", DEBUG_OPTION_REF(debug_lexer), "Enables lexer debug"
"debug_parser", DEBUG_OPTION_REF(debug_parser), "Enables parser debug"
"debug_sizeof", DEBUG_OPTION_REF(debug_sizeof), "Enables special debug messages for sizeof"
"do_not_codegen", DEBUG_OPTION_REF(do_not_codegen), "Does not perform codegen step"
"do_not_run_gdb", DEBUG_OPTION_REF(do_not_run_gdb), "Disables the output of a backtrace using 'gdb' debugger when a signal handler is called"
"enable_debug_code", DEBUG_OPTION_REF(enable_debug_code), "Enable debug code, in general these are debug messages"
"memory_report", DEBUG_OPTION_REF(print_memory_report), "Prints a memory report at the end"
"memory_report_in_bytes", DEBUG_OPTION_REF(print_memory_report_in_bytes), "The memory report is written in bytes"
"print_ast", DEBUG_OPTION_REF(print_ast_graphviz), "Prints ast tree, the tree generated by the parser in Graphviz"
"print_nodecl", DEBUG_OPTION_REF(print_nodecl_graphviz), "Alias of print_nodecl_graphviz"
"print_nodecl_graphviz", DEBUG_OPTION_REF(print_nodecl_graphviz), "Prints nodecl tree in graphviz format"
"print_nodecl_html", DEBUG_OPTION_REF(print_nodecl_html), "Prints nodecl tree in HTML format (requires Javascript-enabled browser)"
"print_parse_tree", DEBUG_OPTION_REF(print_ast_graphviz), "Deprecated alias of print_ast"
"print_pcfg", DEBUG_OPTION_REF(print_pcfg), "Prints PCFG in graphviz format"
"print_pcfg_full", DEBUG_OPTION_REF(print_pcfg_full), "Prints PCFG in graphviz format with Context nodes and Analysis information"
"print_pcfg_w_analysis", DEBUG_OPTION_REF(print_pcfg_w_analysis), "Prints PCFG in graphviz format with Analysis information"
"print_pcfg_w_context", DEBUG_OPTION_REF(print_pcfg_w_context), "Prints PCFG in graphviz format with Context nodes"
"print_scope", DEBUG_OPTION_REF(print_scope), "Prints scope of the translation unit"
"print_tdg", DEBUG_OPTION_REF(print_tdg), "Prints TDG in graphviz format"
"ranges_verbose", DEBUG_OPTION_REF(ranges_verbose), "Prints debug information about range analysis"
"show_template_packs", DEBUG_OPTION_REF(show_template_packs), "Adds a marker to show the extent of a template pack expansion"
"stats_string_table", DEBUG_OPTION_REF(stats_string_table), "Prints statistics of the global string table"
"tdg_to_json", DEBUG_OPTION_REF(tdg_to_json), "Prints TDG in a predefined JSON format"
"tdg_verbose", DEBUG_OPTION_REF(tdg_verbose), "Prints debug information about static Task Dependency Graph generation"
"vectorization_verbose", DEBUG_OPTION_REF(vectorization_verbose), "Enable vectorization debug messages"
%%

static int cmpstringp(const void *p1, const void *p2)
{
    struct debug_flags_list_t** df1 = (struct debug_flags_list_t**) p1;
    struct debug_flags_list_t** df2 = (struct debug_flags_list_t**) p2;

    return strcmp((*df1)->name, (*df2)->name);
}

struct debug_flags_list_t** list_of_debug_flags(void)
{
    struct debug_flags_list_t** result = NULL;

    int i = 0;
    int j = 0;
    while (i < TOTAL_KEYWORDS)
    {
        const char* keyword = debugflags_list[j].name;

        if (keyword != NULL && *keyword != '\0')
        {
            P_LIST_ADD(result, i, &(debugflags_list[j]));
        }

        j++;
    }

    P_LIST_ADD(result, i, NULL);

    qsort(result, i-1, sizeof(struct debug_flags_list_t *), cmpstringp);

    return result;
}
